\section{Implementation}

\subsection{Overview}
This section explains the current implementation of the developed tool set, it
is primarily targeted to fulfill the dissertation's requirements. But is also
aiming to be helpful for users wanting to understand the underlying systems and
prepare them for potentially joining the development effort. Abridged code
extracts are used as of their state for thesis submission, while the main
principles will hold, later readers are asked to please consult the actual
source code if any discrepancies arise or reexport the document. First the main libraries are shortly
explained in their relevance to the program, second the largely abstract plugin
architecture is shown, third the main plugins are presented and last the
delivery processes to the end users are described.


All implementation files are contained and delivered inside a single git
repository, which is freely available online:
\url{https://github.com/ksjogo/oxrti}. All following file paths are relative to that repository's root. All future development will
be immediately available there and the current compiled software version is
always fed automatically from it into the hosted version at \url{https://oxrtimaster.azurewebsites.net/api/azurestatic}.

\subsection{Libraries}
\begin{description}
\item[TypeScript:]  The official header line of TypeScript show some points why
  it was picked for this project: ``TypeScript is a typed superset of JavaScript that compiles
  to plain JavaScript. Any browser. Any host. Any OS\@. Open
  source.''\cite{noauthor_typescript_2018} Which fits
  requirements~\ref{req_os},~\ref{req_system}. Whereas plain JavaScript would
  have allowed slightly easier initial on-boarding and maybe easier immediate
  code `hacks', TypeScript will provide better stability in the long run and a
  quite improved developer experience (requirement~\ref{req_dx}) in the long
  run. With the full typed hook system (compare \autoref{sec_hooks}) it ensures
  that a compiled plugin will not have runtime type problems, reducing the
  amount of switching between code editor and the running software. The whole
  project is setup in a way to fully embrace editor tooling, Visual Studio
  Code\cite *{noauthor_visual_nodate} and Emacs\cite*{noauthor_gnu_nodate} are
  the `officially' tested editors of the project. Code is recommended as it will
  support all developer features out of the box. The installation of the
  tslint\cite*{noauthor_tslint_nodate} plugin\cite*{noauthor_tslint_nodate-1} is
  recommended to keep a consistent code style, which is configured within the
  \emph{tslint.json} file. Most importantly TypeScript adds type declarations
  (and inference) to JavaScript, e.g.:
\begin{typescript}
const thing = function (times: number, other: (index: number) => boolean) { ... }
\end{typescript}
would define \emph{thing} as a function, taking a numbers as first argument and
another function (taking a number as first parameter and returning a boolean) as
second argument. The other most used TypeScript features inside the codebase are
Classes\cite*{noauthor_classes_nodate},
Decorators\cite*{noauthor_decorators_nodate} and
Generics\cite*{noauthor_generics_nodate}, which will be discussed at their first
appearance inside the code samples.

\item[React:] The two main points on React's official website are
  ``Declarative'' and ``Component Based''\cite*{noauthor_react_nodate}, which
  is best shown by an extended example from their website, which exemplifies
  multiple patterns found through the oxrti implementation. The most important
  concept is the jump from having a stateful HTML document, which the JavaScript
  code is manipulating directly, e.g.:
  \begin{typescript}
document.getElementById('gsr').innerHTML="<p>You shouldn't do this</p>"
\end{typescript}
Which is diametric to requirements~\ref{req_easy} and~\ref{req_dx} as it would
require developers to manually keep track of all data cross-references (e.g.\
the pan values having to automatically adapt to the current zoom level). A
declarative approach instead allows much better and easier implemented
reactiveness and better performance (requirements~\ref{req_performance}
and~\ref{req_react}) as the necessary changes can be track and components be
updated selectively.

\begin{typescript}
// a class represents a single component
class Timer extends React.Component {
  // the parent component can pass on props to it
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  tick() {
    //  the state is updated and the component is automatically rerendered
    this.setState(prevState => ({
      seconds: prevState.seconds + 1
    }));
  }

  // called after the component was created/added to the browser window
  componentDidMount() {
    this.interval = setInterval(() => this.tick(), 1000);
  }

  // called before the component will be deleted/removed from the browser window
  componentWillUnmount() {
    clearInterval(this.interval);
  }

  // the actual rendering code
  // html can be directly embedded into react components
  // {} blocks will be evaluated when the render method is called
  // which will happen any time the props or its internal states updates
  render() {
    return (
      <div>
        Seconds: {this.state.seconds}
      </div>
    );
  }
}

// mountNode is a reference to a DOM Node
// the component will be mounted inside that node
ReactDOM.render(<Timer />, mountNode);
\end{typescript}
In conjunction with mobx and TypeScript no classes are used for React components
though, but instead Stateless Functional Components
(`SFCs'\cite*{ikeuchi_react_2017}). These SFCs are plain functions, only
depending on their passed properties:
\begin{typescript}
function SomeComponent(props: any) {
 return <p>{props.first} {props.first}</p>
}
\end{typescript}
This component could then be used by:
\begin{typescript}
 <SomeComponent first="Hello" second="World"/>
\end{typescript}
This component systems allows the plugins to define some components and then
`link' them into the program via the hook system, which will be explored later.
\item[mobx:] Its main tagline is ``Simple, scalable state
  management''\cite*{noauthor_mobx:_2018}. An introducing overview is shown
  in~\autoref{mobxflow}. Broadly speaking MobX introduces observable objects.
  Instead of mentioned DOM handling or property passing inside React trees,
  components can just retrieve their values from the observable objects and will
  be automatically refreshed if the read values change. This for example makes
  the implementation of the QuickPan plugin extremely easy, as it can just read
  the zoom, pan, etc.\ values of the other plugins and will automatically receive
  all updates without any further manual observation handling.
  \sidefig{mobxflow}{MobX Flow}{Taken from
    Weststrate\cite*{noauthor_mobx:_2018}. Actions in the oxrti context are most
  often initially user actions, which are then calling into plugins to change
  the state. The state is mostly encapsulated on a plugin basis with usage of
  the mobx-state-tree library, which also encapsulates most computed values.
  Reactions are most often the previously discussed React components.}
\item[mobx-state-tree:] ``Central in MST (mobx-state-tree) is the concept of a
  living tree. The tree consists of mutable, but strictly protected
  objects''\cite*{noauthor_mobx-state-tree:_2018} This allows the implementation
  to have one shared state tree which can be used to safely access all data. All
  nodes inside the state tree are MobX observables. A simple tree with plain MST
  would look like this:
\begin{typescript}
// define a model type
const Todo = types
 .model("Todo", {
  // state of every model
  title: types.string,
  done: false
 })
 .actions(self => ({
  //methods bounds to the current model instance
  toggle() {
   self.done = !self.done
  }
 }))
// create a tree root, with a property todos
const Store = types.model("Store", {
    todos: types.array(Todo)
})
\end{typescript}
This syntax was deemed to convoluted, as it is a lot more complex than standard
JavaScript/TypeScript classes, which were introduced by the ES6 version, as shown in the React description above and
thus being in conflict with requirement~\ref{req_easy}.
\item[classy-mst:] There is an option to use a more traditional syntax instead
  though, with the classy-mst library, with
  which the example above becomes\cite*{noauthor_classy-mst:_2018}:
\begin{typescript}
const TodoData = types.model({
	title: types.string,
	done: false

});

class TodoCode extends shim(TodoData) {
	@action
	toggle() {
		this.done = !this.done;
	}
}

const Todo = mst(TodoCode, TodoData, 'Todo');
\end{typescript}
 Weststrate, the original author of MobX initially was sceptic of this
 syntax\cite*{noauthor_alternative_nodate} as it was changing the semantics of
 ES6 classes, as classy-mst's methods will be automatically bound to the
 instance. This boundness is an advantage for this implementation though, as the
 hook configurations can just refer to \code{this.someMethod} instead of \code{this.someMethod.bind(this)}.
The \code{@action} is a decorator, enabling the following method to change the
state/properties of the model, as MST prohibits that by default. Reactions/View
updates will only happen after the outermost action finished executing.
\item[WebGL:] The increasing support of the WebGL stack is the main reason, why
  it is now feasible to implement a full RTI software stack with plain web
  technologies, as it ``enables web content to use an API based on OpenGL ES 2.0
  to perform 3D rendering in an HTML \code{<canvas>} in browsers that support it
  without the use of plug-ins."\cite*{noauthor_webgl_nodate-1}
  \fig{webglcomp}{WebGL compability}{WebGL compability as from the Mozilla
    Developer network\cite*{noauthor_webgl_nodate}.}

  \todoT{gl-react}
\item[gl-react:]\todoT{gl-react}
\item[webpack:]\todoT{webpack}\cite{renaudeau_gl-react_2018}
\item[electron:]\todoT{electron}
\item[misc:]\todoT{misc}\cite{noauthor_mobx:_2018}
\end{description}

\subsection{Plugin architectures}
\todoT{Plugin architectures}

\begin{typescript}
  function murks() : number{}
\end{typescript}


\input{fileformats}

\subsection{Loader}


\subsection{State Management}
\todoT{state management}
\todoT{state import/export}
\todoD{redux}
\todoD{mobx actions}

\subsection{Components}
\todoT{single component units}

\subsection{Renderer Stack}
\todoT{base rendering nodes}
\todoD{stacked components}
\todoD{effects}
\subsubsection{Texture Loading}


\subsection{Hooks}\label{sec_hooks}
The hook system allows stable and prioritized interactions between the different
plugins. All available hooks are declared inside the {Hook.tsx} file, which
offers 3 different types of hooks:
\sourceBE{Hook.tsx}
These types are used to first declare single hook types (which will be discussed
within the plugins consuming them) and then construct the whole hook
configuration tree for all plugins:
\begin{typescript}
type HookTypes = {
  ActionBar?: ConfigHook<ActionBar>,
  AfterPluginLoads?: FunctionHook,
  AppView?: ComponentHook,
...
}
\end{typescript}


\subsection{Plugins}
\todoT{Plugins API}

\subsubsection{Base Plugin}
\todoT{Base Plugin}


\subsubsection{BaseTheme Plugin}
\todoT{Basetheme Plugin}

\subsubsection{RedTheme Plugin}

\subsubsection{TabView Plugin}
\source{AppHooksBegin}{AppHooksEnd}{Hook.tsx}
\todoT{TabView Plugin}

\subsubsection{SingleView Plugin}
\todoT{SingleView Plugin}

\subsubsection{Converter Plugin}
\todoT{Converter Plugin}
\subsubsection{PTMConverter Plugin}
\todoT{PTMConverter Plugin}
\subsubsection{Renderer Plugin}
\source{RendererHooksBegin}{RendererHooksEnd}{Hook.tsx}
\todoT{Renderer Plugin}
\todoT{Base Node}
\todoT{WebGL texture packing}
\subsubsection{PTM Renderer Plugin}
\todoT{PTM Renderer Plugin}
\todoT{Dynamic Shaders}
\todoT{RGB vs LRGB}

\subsubsection{Light Control Plugin}
\todoT{Light Control Plugin}
\subsubsection{Rotation Plugin}
\todoT{Rotation Plugin}
\subsubsection{Zoom Plugin}
\todoT{Zoom Plugin}
\subsubsection{QuickPan Plugin}
\todoT{Zoom Plugin}
\subsubsection{Paint Plugin}
\todoT{Zoom Plugin}
\subsubsection{Import Export Plugin }
\todoT{Automatic Import Export}

\subsection{Applications}
\todoT{Other related graphics}
\todoT{Applications}
\subsubsection{Standalone Website}
\todoT{Standalone Website}
\subsubsection{Embeddable}
\todoT{Embeddable}
\subsubsection{Electron}
\todoT{Electron App deliverable}
